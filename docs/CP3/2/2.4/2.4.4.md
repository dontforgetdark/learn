

#  2.4.4. Binary Indexed (Fenwick) Tree

*Lưu ý: trong mục này chỉ số của mảng được đánh số từ 1*

## Cập nhật điểm, tính tổng đoạn (RSQ)

Bài toán: Cho mảng a gồm n phần tử. Có 2 loại truy vấn: 
- Tăng giá trị phần tử a[pos] thêm lượng val.
- Tính tổng các phần tử trong đoạn [l, r]

Code:
```cpp
class FenwickTree {
 private:
  vi ft;  // recall that vi is: typedef vector<int> vi;
 public:
  FenwickTree(int n) { ft.assign(n + 1, 0); }  // init n + 1 zeroes
  int rsq(int b) {                             // returns RSQ(1, b)
    int sum = 0;
    for (; b; b -= LSOne(b)) sum += ft[b];
    return sum;
  }                        // note: LSOne(S) (S & (-S))
  int rsq(int a, int b) {  // returns RSQ(a, b)
    return rsq(b) - (a == 1 ? 0 : rsq(a - 1));
  }
  // adjusts value of the k-th element by v (v can be +ve/inc or -ve/dec)
  void adjust(int k, int v) {  // note: n = ft.size() - 1
    for (; k < (int)ft.size(); k += LSOne(k)) ft[k] += v;
  }
};
int main() {
  int f[] = {2, 4, 5, 5, 6, 6, 6, 7, 7, 8, 9};  // m = 11 scores
  FenwickTree ft(10);  // declare a Fenwick Tree for range [1..10]
  // insert these scores manually one by one into an empty Fenwick Tree
  for (int i = 0; i < 11; i++) ft.adjust(f[i], 1);  // this is O(k log n)
  printf("%d\n", ft.rsq(1, 1));                     // 0 => ft[1] = 0
  printf("%d\n", ft.rsq(1, 2));                     // 1 => ft[2] = 1
  printf("%d\n", ft.rsq(1, 6));   // 7 => ft[6] + ft[4] = 5 + 2 = 7
  printf("%d\n", ft.rsq(1, 10));  // 11 => ft[10] + ft[8] = 1 + 10 = 11
  printf("%d\n", ft.rsq(3, 6));   // 6 => rsq(1, 6) - rsq(1, 2) = 7 - 1
  ft.adjust(5, 2);                // update demo
  printf("%d\n", ft.rsq(1, 10));  // now 13
}  // return 0;
```
## Cập nhật điểm, tính min(max) đoạn (RMQ)

Chú ý:
- Tìm min(max) thì giá trị cập nhật sau phải luôn <=(>=) giá trị trước
- Tất cả các đoạn cần tìm phải có biên trái là 1 hoặc là MAX_SIZE

## Cập nhật đoạn, tính giá trị tại 1 điểm

Bài toán: Cho mảng a có n phần tử. Có 1 loại truy vấn:
- Tăng giá trị đoạn [l, r] thêm val.

Sau cùng xuất ra mảng a.

## So sánh fenwick tree và segment tree

|Feature |Segment Tree| Fenwick Tree|
| ------ |--- | --- |
|Build Tree from Array| O(n) |O(m log n)|
|Dynamic RMin/MaxQ |OK |Very limited|
|Dynamic RSQ |OK |OK|
|Query Complexity |O(log n) |O(log n)|
|Point Update Complexity |O(log n) |O(log n)|
|Length of Code |Longer |Shorter|

## Quan sát phép toán i & -i
Ví dụ: 101 -> 101+1=110 -> 110+10=1000 -> 1000+1000=10000...
tương tự với thao tác trừ, chắc là vịt con đã nhận ra quy luật rồi nhỉ:)
